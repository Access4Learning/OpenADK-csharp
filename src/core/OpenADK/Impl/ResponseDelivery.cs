//
// Copyright (c)1998-2011 Pearson Education, Inc. or its affiliate(s). 
// All rights reserved.
//

using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using OpenADK.Library.Global;
using OpenADK.Library.Infra;
using OpenADK.Util;

namespace OpenADK.Library.Impl
{
    /// <summary>  Sends prepared SIF_Response packets on behalf of a zone.
    /// 
    /// Each ZoneImpl has one instance of ResponseDelivery that it constructs prior
    /// to connecting to the zone. ZoneImpl should call the <c>process</c>
    /// method from an inner thread to cause the Adk to send all outstanding
    /// SIF_Response packets leftover from previous sessions. Subsequently, ZoneImpl
    /// should call this method each time a SIF_Request is successfully handled by
    /// the agent's Publisher to send all pending SIF_Response packets waiting in
    /// the work directory. (Packets are created by the DataObjectFileOutputStream
    /// implementation.)
    /// 
    /// To determine if there are pending SIF_Responses, a directory of all files in
    /// the zone work directory is obtained. Any files without an extension indicate
    /// one or more SIF_Response packets exist for the SIF_Response, and the name of
    /// the file identifies the SourceId and MsgId of the SIF_Request. For each such
    /// file, ResponseDelivery attempts to send each of the packet files named
    /// "{requestSourceId}.{requestMsgId}.{packetNum}.pkt". When all are sent
    /// successfully, the "{requestSourceId}.{requestMsgId}." file is deleted.
    /// 
    /// </summary>
    /// <author>  Eric Petersen
    /// </author>
    /// <version>  Adk 1.0
    /// </version>
    public class ResponseDelivery
    {
        private class ResponseDeliveryFilenameFilter : IFileNameFilter
        {
            #region IFileNameFilter Members

            public bool Accept( FileInfo info,
                                string name )
            {
                return
                    !name.EndsWith( ".pkt" ) && !name.EndsWith( ".rpt" ) && !name.StartsWith( "." );
                // hidden files on some platforms like Mac OS X
            }

            public string SearchPattern
            {
                get { return "*.*"; }
            }

            #endregion
        }


        /// <summary> 	Identifies the generic SIF_Response input directory</summary>
        //public static sbyte SRC_GENERIC = (sbyte) 0;
        /// <summary> 	Identifies the SIF_ReportObject SIF_Response input directory</summary>
        //public static sbyte SRC_SIFREPORTOBJECT = (sbyte) 1;
        /// <summary>  Instruct customers to set this flag to false if they want to see the
        /// output generated by ResponseDelivery in the agent's work/responses
        /// directory (the packet files won't be deleted when the SIF_Responses are
        /// sent.)
        /// </summary>
        public static bool DELETE_ON_SUCCESS = true;

        /// <summary>
        /// The working directory being used by the ResponseDelivery class to read queued messages from
        /// </summary>
        protected internal string fWorkDir;

        /// <summary>
        /// The SIFParser being used to parse objects
        /// </summary>
        protected internal SifParser fParser;

        /// <summary>
        /// The zone that is currently in scope
        /// </summary>
        protected internal ZoneImpl fZone;

        /// <summary>
        /// The source type of this request
        /// </summary>
        protected internal ResponseDeliveryType fSrc;

        internal char [] buf = new char[1024];

        /// <summary>  Constructor.
        /// 
        /// </summary>
        /// <param name="zone">The zone 
        /// 
        /// </param>
        /// <param name="source">Identifies the source of pending SIF_Response packets to 
        /// be processed: <c>RSPTYPE_GENERIC</c> to process files in the default
        /// 'responses' directory, or <c>RSPTYPE_SIFREPORTOBJECT</c> to process
        /// SIF_ReportObject files in the 'responses/reports' directory
        /// </param>
        public ResponseDelivery( IZone zone,
                                 ResponseDeliveryType source )
        {
            fZone = (ZoneImpl) zone;
            fParser = SifParser.NewInstance();
            fSrc = source;
            fWorkDir = GetSourceDirectory( source, fZone );
        }

        /// <summary> 	Determines the full path to the source directory.
        /// 
        /// All SIF_Response source directories are located in the agent's work directory.
        /// Generic SIF_Responses are found in a directory named "{agent-home}/work/{zoneId}_{zoneHost}/responses/".
        /// SIF_Responses for SIF_ReportObject requests are found in a directory named
        /// "{agent-home}/work/{zoneId}_{zoneHost}/responses/reports".
        /// 
        /// </summary>
        /// <param name="zone">The associated zone
        /// </param>
        /// <param name="source">Identifies the type of pending SIF_Response packets. This flag may
        /// be any <c>SRC_</c> constant defined by this class. 
        /// </param>
        /// <returns> The fully-qualified path to the directory where pending response packets
        /// are located for the type of responses identified by <i>source</i>
        /// </returns>
        public static string GetSourceDirectory( ResponseDeliveryType source,
                                                 IZone zone )
        {
            StringBuilder workDir = new StringBuilder();

            workDir.Append( zone.Agent.WorkDir );
            if ( workDir[workDir.Length - 1] != Path.DirectorySeparatorChar ) {
                workDir.Append( Path.DirectorySeparatorChar );
            }
            workDir.Append( AdkStringUtils.SafePathString( zone.ZoneId + "_" + zone.ZoneUrl.Host ) );
            workDir.Append( Path.DirectorySeparatorChar.ToString() );
            workDir.Append( "responses" );
            if ( source == ResponseDeliveryType.SIFReportObject ) {
                workDir.Append( Path.DirectorySeparatorChar.ToString() );
                workDir.Append( "reports" );
            }

            return workDir.ToString();
        }

        /// <summary> 	Determines if the specified source directory exists and contains one or more files.</summary>
        /// <param name="source">Identifies the type of pending SIF_Response packets. This flag may
        /// be any <c>SRC_</c> constant defined by this class. 
        /// </param>
        /// <returns> <c>true</c> if the source directory exists and contains at least one file
        /// </returns>
        /// <param name="zone"></param>
        public static bool HasPendingPackets( ResponseDeliveryType source,
                                              IZone zone )
        {
            DirectoryInfo dir = new DirectoryInfo( GetSourceDirectory( source, zone ) );
            if ( dir.Exists ) {
                FileInfo [] contents = dir.GetFiles();
                return contents.Length > 0;
            }
            return false;
        }

        /// <summary>  Signal the ResponseDelivery thread that SIF_Response packets are available
        /// for sending to the zone.
        /// </summary>
        [MethodImpl(MethodImplOptions.Synchronized)]
        public virtual void Process()
        {
            //  Look for all non-"*.pkt" files; if a file doesn't end in an extension,
            //	it has no content and represents a pending SIF_Response. These are the
            //	files we're interested in processing in the files[] loop below.
            DirectoryInfo dir = new DirectoryInfo( fWorkDir );

            FileInfo[] files =
                DirectorySearcher.GetFiles( dir, new ResponseDeliveryFilenameFilter() );

            //bool errorPacket = false;

            if ( files != null && files.Length > 0 )
            {
                if ( ((Adk.Debug & AdkDebugFlags.Messaging_Response_Processing) != 0) )
                {
                    fZone.Log.Debug
                        ( "Processing " + (files.Length) + " pending SIF_Response packets..." );
                }

                for ( int i = 0; i < files.Length; i++ )
                {
                    string fileName = files[i].Name;
				    bool responseHasMorePackets = fileName.EndsWith( "Y" );
				    string _msgId = fileName.Substring( 0, fileName.Length - 2 );

                    //  Get all packets awaiting delivery...
                    FileInfo[] packets = dir.GetFiles( _msgId + "*.pkt" );

                    if ( packets.Length == 0 )
                    {
                        continue;
                    }

                    if ( (Adk.Debug & AdkDebugFlags.Messaging_Response_Processing) != 0 )
                    {
                        fZone.Log.Debug
                            ( "Found " + (packets.Length) +
                              " pending SIF_Response packets for request " +
                              _msgId );
                    }

                    //  Sort the files by packet #
                    Array.Sort( packets, delegate( FileInfo o1, FileInfo o2 )
                                    {
                                        int o1Packet = int.Parse(  o1.Name.Split( '.' )[2] );
                                        int o2Packet = int.Parse(  o2.Name.Split( '.' )[2] );
                                  
                                        if ( o1Packet < o2Packet )
                                        {
                                            return -1;
                                        }
                                        else if ( o1Packet == o2Packet )
                                        {
                                            return 0;
                                        }
                                        return 1;
                                    } );

                    //  Process each packet
                    int p ;
                    for ( p = 0; p < packets.Length; p++ )
                    {
                        bool morePackets = responseHasMorePackets || (p < (packets.Length - 1));
                        SendPacket(packets[p], morePackets);
                    }

                    //  Delete files[i] if we processed all packets. If the
                    //  thread is being shut down and not all packets were
                    //  processed, however, leave the file for the next
                    //  session.
                    if ( p >= packets.Length )
                    {
                        //	System.out.println( "Deleting " + files[i].getAbsolutePath() );
                        if ( File.Exists( files[i].FullName ) )
                        {
                            File.Delete( files[i].FullName );
                        }
                        else if ( Directory.Exists( files[i].FullName ) )
                        {
                            Directory.Delete( files[i].FullName );
                        }

                        if ( fSrc == ResponseDeliveryType.SIFReportObject )
                        {
                            //	SRC_SIFREPORTOBJECT: Also delete the .rpt file
                            FileInfo f =
                                new FileInfo
                                    ( fWorkDir + Path.DirectorySeparatorChar.ToString() + _msgId +
                                      ".rpt" );
                            //	System.out.println( "Deleting " + f.getAbsolutePath() );
                            if ( File.Exists( f.FullName ) )
                            {
                                File.Delete( f.FullName );
                            }
                            else if ( Directory.Exists( f.FullName ) )
                            {
                                Directory.Delete( f.FullName );
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// The delivery type that will be used for processing
        /// </summary>
        public ResponseDeliveryType ProcessingType
        {
            get { return fSrc; }
        }

        /// <summary>
        /// Sends a specific packet to the zone
        /// </summary>
        /// <param name="file"></param>
        /// <param name="morePackets"></param>
        protected internal virtual void SendPacket( FileInfo file,
                                                    bool morePackets )
        {
            long extraBytes = 0;

            ResponsePacketInfo responsePacket = DeserializeResponseFileName( file.Name );

            /*	If we're processing SIF_ReportObject responses, read the ReportInfo
             *	data from the "requestMsgId.rpt" file
             * 
             *  TT 894 - If a SIFException is thrown after the ReportInfo is set on 
    	     *  the ReportObjectStream, then we don't want to include that ReportInfo
    	     *  in the packet with the error.  In that case, rptInfoReader will be 
    	     *  null and will not be included in the list of payloads below.
             */

            FileStream rptInfoStream = null;
            if ( fSrc == ResponseDeliveryType.SIFReportObject && !responsePacket.errorPacket ) {
                try {
                    FileInfo f =
                        new FileInfo
                            ( fWorkDir + Path.DirectorySeparatorChar.ToString() + responsePacket.destinationId + "." +
                              responsePacket.requestMsgId + ".rpt" );
                    rptInfoStream = f.OpenRead();
                    extraBytes = f.Length;
                }
                catch ( FileNotFoundException fnfe ) {
                    fZone.Log.Debug
                        ("Error sending SIF_ReportObject packet #" + responsePacket.packetNumber + (morePackets ? "" : " (last packet)") + ", file not found: " + fnfe.Message );
                }
            }

            if ( (Adk.Debug & AdkDebugFlags.Messaging) != 0 ) {
                fZone.Log.Debug
                    ( "Sending " + (responsePacket.errorPacket ? "SIF_Error response" : "SIF_Response") +
                      " packet #" + responsePacket.packetNumber +
                      ( morePackets ? "" : " (last packet)" ) );
            }

            //  Prepare SIF_Response
            SIF_Response rsp = new SIF_Response();
            rsp.SetSIF_MorePackets( morePackets ? YesNo.YES : YesNo.NO );
            rsp.SIF_RequestMsgId = responsePacket.requestMsgId;
            rsp.SIF_PacketNumber = responsePacket.packetNumber;

            //  The SIF_Response is rendered in the same version of SIF as the original SIF_Request
            rsp.SifVersion = responsePacket.version;

            if (responsePacket.errorPacket)
            {
                //  Write an empty "<SIF_Error> </SIF_Error>" for the MessageStreamer
                //  to replace
                SIF_Error err = new SIF_Error();
                err.TextValue=" ";
                rsp.SIF_Error=err ;
            }

            if (!responsePacket.errorPacket || responsePacket.version.Major == 1)
            {
                //  Write an empty "<SIF_ObjectData> </SIFObjectData>" for the
                //  MessageStreamer to fill in. If this is an errorPacket, the empty
                //  element is required per the SIF 1.x Specifications, but disallowed
                // in SIF 2.x.
                SIF_ObjectData placeholder = new SIF_ObjectData();
                placeholder.TextValue =" ";
                rsp.SIF_ObjectData = placeholder;
            }


            //  Assign values to message header - this is usually done by
            //  MessageDispatcher.send() but because we're preparing a SIF_Response
            //  output stream we need to do it manually
            SIF_Header hdr = rsp.Header;
            hdr.SIF_Timestamp = DateTime.Now;
            hdr.SIF_MsgId = SifFormatter.GuidToSifRefID( Guid.NewGuid() );
            hdr.SIF_SourceId = fZone.Agent.Id;
            hdr.SIF_Security = fZone.Dispatcher.secureChannel();
            hdr.SIF_DestinationId = responsePacket.destinationId;

            //  Write SIF_Response -- without its SIF_ObjectData payload -- to a buffer
            using ( MemoryStream envelope = new MemoryStream() ) {
                SifWriter writer = new SifWriter( envelope );
                writer.Write( rsp );
                writer.Flush();
                envelope.Seek( 0, SeekOrigin.Begin );

                FileStream fs = file.OpenRead();
                try {
                    //  Send the SIF_Response as a stream
                    Stream [] payloads;
                    if ( fSrc == ResponseDeliveryType.Generic ) {
                        payloads = new Stream [] {fs};
                    }
                    else {
                        if ( rptInfoStream != null ) {
                            payloads = new Stream [] {rptInfoStream, fs};
                        }
                        else {
                            payloads = new Stream [] {fs};
                        }
                    }

                    using ( MessageStreamer ms = new MessageStreamer
                        (
                        envelope,
                        payloads,
                        responsePacket.errorPacket ? "<SIF_Error>" : "<SIF_ObjectData>", responsePacket.errorPacket))
                    {
                        if ( (Adk.Debug & AdkDebugFlags.Messaging) != 0 ) {
                            fZone.Log.Debug( "Send SIF_Response" );
                        }
                        if ( (Adk.Debug & AdkDebugFlags.Messaging_Detailed) != 0 ) {
                            fZone.Log.Debug( "  MsgId: " + rsp.MsgId );
                        }

                        SIF_Ack ack;
                        using ( IMessageInputStream ackStream = fZone.ProtocolHandler.Send( ms ) ) {
                            ack =
                                (SIF_Ack)
                                fParser.Parse
                                    ( ackStream.GetInputStream(), fZone, SifParserFlags.None );
                        }
                        if ( ack != null ) {
                            ack.LogRecv( fZone.Log );
                        }
                    }

                    //  If we get here, the message was sent successfully
                    envelope.Close();

                    for ( int i = 0; i < payloads.Length; i++ ) {
                        payloads[i].Close();
                    }
                    fs.Close();

                    if ( DELETE_ON_SUCCESS && file.Exists ) {
                        file.Delete();
                    }
                }
                catch ( AdkException adke ) {
                    AdkUtils._throw( adke, fZone.Log );
                }
                catch ( Exception e ) {
                    AdkUtils._throw
                        ( new AdkException( "Failed to send SIF_Response: " + e, fZone ), fZone.Log );
                }
                finally {
                    if ( fs != null ) {
                        fs.Close();
                    }
                    if ( rptInfoStream != null ) {
                        rptInfoStream.Close();
                    }
                }
            }
        }

        /**
         * This method is implemented here to be in close proximity to the method that parses a file name to 
         * retrieve these bits of information back out
         * @param builder
         * @param destinationId
         * @param requestMsgId
         * @param packetNumber
         * @param renderAsVersion
         * @param errorPacket
         */
        internal static void SerializeResponsePacketFileName(StringBuilder builder, String destinationId, String requestMsgId,
                int packetNumber, SifVersion renderAsVersion, bool errorPacket)
        {

            // FORMAT: "{requestSourceId}.{requestMsgId}.{packet#}.{ver}[.$].pkt"

            builder.Append(serializeToken( destinationId ));
            builder.Append('.');
            builder.Append(requestMsgId);
            builder.Append('.');
            builder.Append(packetNumber);
            builder.Append('.');
            builder.Append(renderAsVersion.ToSymbol());

            if (errorPacket)
            {
                builder.Append(".$");
            }
            builder.Append(".pkt");
        }

        internal static String SerializeResponseHeaderFileName(String destinationId, String requestMsgId, bool morePackets)
        {
            return serializeToken( destinationId ) + '.' + requestMsgId + '.' + (morePackets ? 'Y' : 'N');
        }

        	

	    private static String serializeToken(String destinationId) {
		    destinationId = destinationId.Replace( ".", "~~" );
            destinationId = System.Web.HttpUtility.UrlEncode( destinationId, Encoding.UTF8 );
		    return destinationId;
	    }

	    private static String deserializeToken(String destinationId ) {
		    destinationId = System.Web.HttpUtility.UrlDecode( destinationId, Encoding.UTF8 );
		    destinationId = destinationId.Replace( "~~", "." );
		    return destinationId;
	    }

        private static ResponsePacketInfo DeserializeResponseFileName(String shortFileName)
        {

            ResponsePacketInfo responsePacket = new ResponsePacketInfo();

            //  Get SIF_DestinationId, SIF_RequestMsgId, and SIF_PacketNumber from
            //  the filename
            //	FORMAT: "{requestSourceId}.{requestMsgId}.{packet#}.{ver}.{morePackets}[.$].pkt"

            //  the filename "{requestSourceId}.{requestMsgId}.{packet#}.pkt"
            string [] tokens = shortFileName.Split( '.' );
            String destId = tokens[0];
            destId = deserializeToken(destId);
            responsePacket.destinationId = destId;
            responsePacket.requestMsgId = tokens[1];
            responsePacket.packetNumber = int.Parse(tokens[2]);
            string ver = tokens[3];
            ver = ver.Replace('_', '.');
            responsePacket.version = SifVersion.Parse(ver);

            //  A leading $ on the filename indicates this is a response packet
            //  with a SIF_Error
            responsePacket.errorPacket = shortFileName.EndsWith("$.pkt");

            return responsePacket;

        }

        private sealed class ResponsePacketInfo
        {
            public bool errorPacket = false;
            public String destinationId;
            public String requestMsgId;
            public int packetNumber;
            public SifVersion version;
        }
    }
}
